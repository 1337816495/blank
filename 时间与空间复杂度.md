# 复杂度

## 概述

算法是通过操纵数据来解决问题的方法，计算机执行算法需要消耗时间与内存，不同算法对时间与内存的消耗程度大不相同。我们通常会从时间和空间两个维度来分析算法的效率，以便于筛选出更加合适的算法，时间维度上的衡量指标是时间复杂度，空间维度上的衡量指标是空间复杂度。

在实践中，一个算法通常会存在最好、最坏、平均三种情况，我们一般关注最坏情况。

## 时间复杂度

时间复杂度用于表示算法在时间维度上的效率，具体来说它代表了算法所执行的语句的次数随着问题规模 n 的变化而变化的规律。

因为一个算法在不同性能的机器上的运行时间会大不相同，所以我们不能直接使用算法的真实运行时间来作为它的时间复杂度。取而代之的是，我们会使用渐进时间复杂度来作为它算法的时间复杂度，在介绍渐进的时间复杂度之前，我们需要先理解下面几个概念。

### 时间频度

时间频度的符号是 `T(n)`，它代表一个算法会执行多少次语句。时间频度的意义是可以更加简单的反映出算法的耗时，因为我们很难统计出每条语句的具体耗时，不过我们至少可以认为算法的耗时与语句的执行次数成正比，当算法需要执行的语句的次数越多时，算法消耗的时间也会越长。

`T(n)` 中的 n 代表问题的规模，比如对于一个函数而言，n 代表函数的输入值。`T(n)` 只能表示算法在某个特定规模下的效率，但我们往往需要知道算法在任意规模下的效率，这样才方便我们直观的感受到不同的算法在不同规模的场景下的效率的优劣。

不过，我们根本无法穷举出算法在所有规模下的效率，因为规模的数量是无穷的，所以我们不能通过暴力的计算出 `T(n)` 在每种 n 下的值来模拟出算法在任意规模下的效率，取而代之的方法是，我们会通过计算出 `T(n)` 随着 n 的变化所呈现出的规律来模拟算法在任意规模下的效率。

### 渐进时间复杂度

渐进时间复杂度就是 `T(n)` 随着 n 的变化所呈现出的规律，而时间复杂度正是渐进时间复杂度的简称，在下文中，我会使用时间复杂度这一术语来代表渐进时间复杂度。

时间复杂度的符号是 `O( f(n) )`，其中 `f(n)` 代表一个与 `T(n)` 同数量级的函数，其中 `O( f(n) )` 代表存在一个常数 C，可以使得 `T(n) <= C * f(n)`。这代表着我们可以用 `f(n)` 来近似的模拟 `T(n)`，并通过观察 `f(n)` 的曲线来粗略的判断出 `T(n)` 在不同规模（n）下的变化规律，毕竟 `f(n)` 和 `T(n)` 是同一数量级的函数。另外，当 n 趋近于无穷时，`f(n)` 会越来越贴近 `T(n)`。

为了更简洁的表示出算法的时间复杂度，我们还可以简化 `f(n)`，只要保证 `f(n)` 与 `T(n)` 在同一数量级即可，所以我们会把常数级别的时间复杂度写作 `O(1)`，而不是更复杂的 `O(2)`、`O(100)`或其他。另外，我们也会省略对数函数的底数，来简化对数级别的时间复杂度，比如把 `O(log2 n)` 简写为 `O(log n)`。

最后，我们就得到了下文这些常见的时间复杂度模型，并按照复杂度由低到高的顺序进行了排序：

1. `O(1)`
2. `O(log n)`
3. `O(n)`
4. `O(nlog n)`
5. `O(n^2)`
6. `O(n^3)`
7. ......
8. `O(2^n)`
9. `O(n!)`

另外，在为具体场景选择算法时，我们还必须基于场景的规模 n 来进行选择，而不能一昧认为时间复杂度低的算法的效率就更高，比如当问题规模 n 很小时，`O(2^n)` 比 `O(1)` 更小，当问题规模 n 很大时，`O(2^n)` 比 `O(1)` 更大。

### 计算时间复杂度



- 如果计算时间 `T(n) = 常数`，那么时间复杂度为 `O(1)`
- 如果计算时间 `T(n) = 常数 * n + 常数`，那么时间复杂度为 `O(n)`。
- 如果 `T(n)` 是一个更复杂的多项式，那么时间复杂度就是 `O(n^最高次幂)`，比如 `T(n) = 5n^3 + 4n^2 + 3n` 对应的时间复杂度是 `O(n^3)`。

> 对于第二和第三条，我们之所以可以省略掉式子中的低次幂项、常数项和系数，是因为随着 n 的增长，这些项与系数对计算时间或时间复杂度的影响会越来越小，为了更加简洁的表示程序的时间复杂度，我们干脆就省略掉了它们。
>
> 另外，如果时间复杂度是一个对数，我们还会省略掉对数的底数。

另外，如果一段程序的时间复杂度会随着输入值的不同而显著不同的话，我们就总是会取最坏情况下的时间复杂度作为最终的时间复杂度，比如下面这段程序的时间复杂度是 `O(n)` 而不是 `O(1)`。

```js
function f ( n ) {
    
    if ( n > 100 ) return 1;
    else for ( let i = 0; i < n; i++ ) console.log( n );
    
}
```

下面我们来分析一些经典函数的时间复杂度。

## 例子 1

```js
function f ( n ) {
    
    for ( let i = 0; i < n; i++ ) {
        
        for ( let j = i; j < n; j++ ) {
            
            console.log( j );
            
        }
        
    }
    
}
```

首先，该函数的 `T(n)` 等于 `n + (n-1) + (n-2) + ... + 2 + 1`，即 `(n+1) * (n/2)`，化简为 `1/2*n^2 + 1/2*n`，因此该函数的时间复杂度是 `O(n^2)`。

## 例子 2

```js
function f ( n ) {
    
    for ( let i = 1; i < n; i *= 2 ) console.log( i );
    
}
```

首先分析该函数的 `T(n)`，假设该函数会执行 x 次 `console.log( i )` 语句，那么易得该函数会执行 1 次 `let i = 1`、x + 1 次 `i < n`、x 次 `i *= 2`，那么 `T(n) = 3*x + 2`，对应的时间复杂度就是 `O(x)`。

那么 x 又是多少呢？通过实践容易发现，当 n 为 4 时，x 为 2，当 n 为 8 时，x 为 3，当 n 为 16 时，x 为 4，...，因此 x 为 `log2 n`。

当时间复杂度为对数时，我们会忽略掉底数，因此最后的时间复杂度是 `O(log n)`。

## 例子 3

假设某算法的计算时间表示为递推的关系式：`T(n) = T(n-1) + n`（其中 n 为正整数），以及已知 `T(0) = 1`，求该算法的时间复杂度。

```
因为 T(n) = T(n-1) + n
可得 T(n-1) = T(n-2) + (n-1)
可得 T(n-2) = T(n-3) + (n-2)
可得 T(n-3) = T(n-4) + (n-3)
可得 ......

通过套娃可以得到：
T(n) = T(n-2) + (n-1) + n
	 = T(n-3) + (n-2) + (n-1) + n
	 = T(n-4) + (n-3) + (n-2) + (n-1) + n
	 = ......
	 = T(0) + 1 + 2 + 3 + ... + n
	 = 1 + (1+n) * (n/2)
	 = (1/2) * (n^2) + (1/2) * n + 1
因此时间复杂度为 O(n^2)
```