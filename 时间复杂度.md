# 时间复杂度

## 计算时间

我们使用 `T(n)` 来表示一段程序在输入值为 n 的时候将会执行多少次语句，语句的执行次数就代表了这段程序的计算时间。比如下述代码的计算时间 `T(n)` 是 `2n+1`，因为它会执行 n 次 `n--`、n 次 `console.log(n)`、1 次 `return n`。

```js
function f ( n ) { 

    while ( n -- ) console.log( n );

    return n;
    
}
```

## 时间复杂度

在实践中，我们不会使用计算时间 `T(n)` 来衡量程序的效率，因为我们很难统计一段程序具体会执行多少次语句。取而代之的，我们会使用计算时间的简化值来衡量程序的效率，这个简化值就是时间复杂度，符号为 `O(n)`。

而如何将 `T(n)` 转化为 `O(n)` 呢？规则如下：

- 如果计算时间 `T(n) = 常数`，那么时间复杂度为 `O(1)`
- 如果计算时间 `T(n) = 常数 * n + 常数`，那么时间复杂度为 `O(n)`。
- 如果 `T(n)` 是一个更复杂的多项式，那么时间复杂度就是 `O(n^最高次幂)`，比如 `T(n) = 5n^3 + 4n^2 + 3n` 对应的时间复杂度是 `O(n^3)`。

> 对于第二和第三条，我们之所以可以省略掉式子中的低次幂项、常数项和系数，是因为随着 n 的增长，这些项与系数对计算时间或时间复杂度的影响会越来越小，为了更加简洁的表示程序的时间复杂度，我们干脆就省略掉了它们。
>
> 另外，如果时间复杂度是一个对数，我们还会省略掉对数的底数。

另外，如果一段程序的时间复杂度会随着输入值的不同而显著不同的话，我们就总是会取最坏情况下的时间复杂度作为最终的时间复杂度，比如下面这段程序的时间复杂度是 `O(n)` 而不是 `O(1)`。

```js
function f ( n ) {
    
    if ( n > 100 ) return 1;
    else for ( let i = 0; i < n; i++ ) console.log( n );
    
}
```

下面我们来分析一些经典函数的时间复杂度。

## 例子 1

```js
function f ( n ) {
    
    for ( let i = 0; i < n; i++ ) {
        
        for ( let j = i; j < n; j++ ) {
            
            console.log( j );
            
        }
        
    }
    
}
```

首先，该函数的 `T(n)` 等于 `n + (n-1) + (n-2) + ... + 2 + 1`，即 `(n+1) * (n/2)`，化简为 `1/2*n^2 + 1/2*n`，因此该函数的时间复杂度是 `O(n^2)`。

## 例子 2

```js
function f ( n ) {
    
    for ( let i = 1; i < n; i *= 2 ) console.log( i );
    
}
```

首先分析该函数的 `T(n)`，假设该函数会执行 x 次 `console.log( i )` 语句，那么易得该函数会执行 1 次 `let i = 1`、x + 1 次 `i < n`、x 次 `i *= 2`，那么 `T(n) = 3*x + 2`，对应的时间复杂度就是 `O(x)`。

那么 x 又是多少呢？通过实践容易发现，当 n 为 4 时，x 为 2，当 n 为 8 时，x 为 3，当 n 为 16 时，x 为 4，...，因此 x 为 `log2 n`。

当时间复杂度为对数时，我们会忽略掉底数，因此最后的时间复杂度是 `O(log n)`。

## 例子 3

假设某算法的计算时间表示为递推的关系式：`T(n) = T(n-1) + n`（其中 n 为正整数），以及已知 `T(0) = 1`，求该算法的时间复杂度。

```
因为 T(n) = T(n-1) + n
可得 T(n-1) = T(n-2) + (n-1)
可得 T(n-2) = T(n-3) + (n-2)
可得 T(n-3) = T(n-4) + (n-3)
可得 ......

通过套娃可以得到：
T(n) = T(n-2) + (n-1) + n
	 = T(n-3) + (n-2) + (n-1) + n
	 = T(n-4) + (n-3) + (n-2) + (n-1) + n
	 = ......
	 = T(0) + 1 + 2 + 3 + ... + n
	 = 1 + (1+n) * (n/2)
	 = (1/2) * (n^2) + (1/2) * n + 1
因此时间复杂度为 O(n^2)
```