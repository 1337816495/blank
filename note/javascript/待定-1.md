# ⏳ 数据类型

​		数据类型描述了值的特征与行为方式。 ECMAScript 定义了 8 种数据类型，其中有 7 种原始类型和 1 种引用类型。

​		原始类型又被称为基本数据类型，原始类型的值被称为原始值。

​		引用类型又被称为复杂数据类型，引用类型的值被称为引用值。

| 原始类型    |
| ----------- |
| `Number`    |
| `String`    |
| `Boolean`   |
| `Undefined` |
| `Null`      |
| `Symbol`    |
| `Bigint`    |

| 引用类型 |
| -------- |
| `Object` |



## ⏳ 存储在堆栈

​		原始值存储在栈（ stack ）中，可以被引擎直接访问到。引用值存储在堆（ heap ）中，只能被引擎通过栈中的指针来间接访问到。

> ⏳：重绘一张关于 “原始值和引用值如何存储在堆栈上” 的图片，你需要参考《浏览器原理》。下图是错误的，因为它把堆画成了栈结构。

![](C:/Users/Lenovo/Pictures/typora%E5%9B%BE%E7%89%87%E4%BB%93%E5%BA%93/stack_heap.png)

**为什么：**

> ⏳：结合《浏览器原理》来修改此小节

​		原因一：

​		原始值所需的空间是固定的，引用值所需的空间是不定的。
​		如果只在栈中存储原始值，那么栈中的相邻两个值的地址的偏移量就是固定的，引擎可以通过计算偏移量来直接确定一个值的地址，这样就能加速值查询的速度。如果在栈中存储引用值，就无法利用这种特性了。
​		虽然栈不存储引用值，但是栈可以存储引用值在堆中的地址，这个地址所需的空间也是固定的。

​		原因二：

​		栈的存储空间小，堆的存储空间大。原始值所需的存储空间小，引用值所需的存储空间大。所以，栈天生就适合存储原始值。如果在栈中存储引用值，就容易爆栈。



**值的传递：**

​		在 JavaScript 中，赋值的本质是将变量 A 在栈中的值复制一份交给变量 B ，最后变量 A 和 B 在栈中的值相同。
​		因为原始值在栈中存储的是值本身，引用值在栈中存储的是值的引用，所以原始值通过「值复制」的方式来传递值，引用值通过「引用复制」的方式来传递值。



## ⏳ Number

> ⏳：根据《 JavaScript 悟道》来进行修改
>

**小数精确难题：**

​		JavaScript 遵循 IEEE 754 标准的子集来制定数字类型，JavaScript 的数字类型最终表现为采用 64 位来存储数字，其中的 52 位用于存储整数， 11 位用于存储小数， 1 位用于存储符号。

​		某些十进制的小数在被转换为二进制后，将从有限小数变为无限小数，比如：

```
十进制0.5 => 二进制0.1
十进制0.1 => 二进制0.000110011001100...
```

​		然而，用于存储一个数字的内存是有限的（64位），因此无限小数会被取舍为有限小数（遵循四舍五入），此时便产生了误差。比如 JavaScript 中的 0.1 并不等于 0.1 ，而是：

```js
0.1.toFixed(20); // '0.10000000000000000555'
0.2.toFixed(20); // '0.20000000000000001110'
0.3.toFixed(20); // '0.29999999999999998890'
```

​		这会引发一个荒谬的错误，即 `(0.1 + 0.2) === 0.3; // false` ，这是因为：

```js
(0.1 + 0.2).toFixed(20); // '0.30000000000000004441'
```

**解决小数精确难题：**

​		假如 2 个数字值的差值小于机器精度，便可认为这 2 个数字值是完全相等的，该方法源自《You don't know JS》。

```js
Number.EPSILON; //机器精度
```

```js
function numberCloseEnoughToEqual(a, b) {
    
    const is_equal = Math.abs(a - b) < Number.EPSILON;
    
    return is_equal;
    
}

numberCloseEnoughToEqual((0.1 + 0.2), 0.3); // true
```

​		`Number.EPSILON` 是 ES6 提供的特性，假如运行时还没有实现该特性，可以使用这个 polyfill：

```js
if (!Number.EPSILON) {
    
	Number.EPSILON = Math.pow(2, -52); // 2.220446049250313e-16
    
}
```

**关于 0 ：**

​		在小数中，可以省略小数点前的 `0` ：

```js
.1 === 0.1; // true
```

​		在小数中，小数部分的最后的 `0` 会被忽略：

```js
console.log(.100); // 0.1
```

​		`0` 、 `+0` 、 `-0` 三者是一样的：

```js
 0 === +0; // true
 0 === -0; // true
+0 === -0; // true
```

**科学计数法：**

​		格式是： `底数 + e或E + 指数` ，如：

```js
2.5e5;  // 250000
2.5e+5; // 250000
2.5e-5; // 0.000025
2.5E+5; // 250000
2.5E-5; // 0.000025
```

**更多进制：**

```js
0b11; // 二进制  : 3
0o77; // 八进制  : 63
0xff; // 十六进制: 255
```

​		注意，以 `0` 为前缀的八进制表示法已经被淘汰了。

继续！！！！！！！！！！从 #其它进制 开始



# 以下内容应该放在哪里呢？



## 赋值未定义变量会创建全局变量的原因

```js
function f() {
    
    temp = 1; // 等价于 this.temp = 1;
    
}
```

​		由于 `temp` 没有被 `var` 、 `let` 、 `const` 声明，所以 JavaScript 引擎会以 `this.temp` 来替换 `temp` ，而在非严格模式下，这里的 `this` 指向了 `window` 。

​		这种 “赋值未定义变量会创建全局变量” 的情况，在全局作用域内也会出现，为什么呢？是因为全局作用域会被当作一个匿名函数吗？（因为全局作用域在执行的时候会被包装进一个匿名函数内来执行）。





## JavaScript URIs

​		当用户点击 `javascript:;` 的URI时，它会执行URI中的代码，然后用返回值替换整个页面的内容，除非返回值是 `undefined`。

```html
<!-- 点击后，返回的0会替换整个页面，对Chrome无效，对Firefox有效 -->
<a href="javascript: 0;"></a>
```

```html
<!-- 点击后，因为代码返回undefined，所以不会替换页面 -->
<a href="javascript:;"></a>
<a href="javascript: void 0;"></a>
<a href="javascript: void(0);"></a>
```

```html
<!-- 点击后，虽然不会替换页面，但是会改变页面样式 -->
<a href="javascript: void(document.body.style.backgroundColor='pink');"></a>
```

```html
<!-- 点击后，跳转至页首 -->
<a href="#"></a>
```

```html
<!-- 点击后，跳转至目标锚点 -->
<a href="#+id"></a>
```

```html
<!-- 点击后，无响应 -->
<a href="###"></a>
```



## 函数 arguments

​		由关键字 `function`  创建的函数对象的内部拥有一个隐藏变量 `arguments` ，它是一个按入参顺序来浅拷贝了所有入参的类数组。

```js
const f1 = function() { console.log(arguments); };

function f2() { console.log(arguments); }

f1(1, 2, 3); // Arguments(3) [1, 2, 3]
f2(1, 2, 3); // Arguments(3) [1, 2, 3]
```



## alert / prompt / confirm

## alert

​		令浏览器显示一个模态对话框，其上显示指定的文本和确定按钮。在对话框存活期间，用户只能和对话框进行交互。

**语法：**

```js
window.alert( message );
```

```js
alert( message );
```

**参数：**

- message：可选，String，用于显示的文本，若传入非字符串类型的值，则会被隐式转换为字符串

**返回：**

- `undefined`



## prompt

​		令浏览器显示一个模态对话框，其上显示指定的文本、输入框、确定按钮、取消按钮。在对话框存活期间，用户只能和对话框进行交互。

**语法：**

```js
prompt( message, value );
```

```js
window.prompt( message, value );
```

**参数：**

- message：可选，String，用于显示的文本，若传入非字符串类型的值，则会被隐式转换为字符串
- value：可选，String，输入框的默认值，若传入非字符串类型的值，则会被隐式转换为字符串

**返回：**

- String：若点击确定按钮，则返回输入框内的 String 
- Null：若点击取消按钮或按下 Esc 键，则返回 `null`

**陷阱：**

- IE 7/8 中，省略第二个入参时，输入框的默认值是 `undefined` （字符串）。推荐总是提供第二个入参来兼容 IE 7/8，如下：

```js
prompt('', '');
```



## confirm

​		令浏览器显示一个模态对话框，其上显示指定的文本、确定按钮、取消按钮。在对话框存活期间，用户只能和对话框进行交互。

**语法：**

```js
confirm( message );
```

```
window.confirm( message );
```

**参数：**

- message：可选，String，用于显示的文本，若传入非字符串类型的值，则会被隐式转换为字符串

**返回：**

- Boolean，若点击确定按钮，则返回 `true`，若点击取消按钮或按下 Esc 键，则返回 `false`

