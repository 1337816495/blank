# 运算符

优先级更高的运算符被优先执行，优先级相同的运算符，按关联性的方向来执行。

| 优先级 | 名称                  | 关联性   | 运算符                 |
| ------ | --------------------- | -------- | ---------------------- |
| 21     | 圆括号                | 无       | `(...)`                |
| 20     | 点号属性访问器        | 从左到右 | `obj.prop`             |
| 20     | 方括号属性访问器      | 从左到右 | `obj[expr]`            |
| 20     | new（有参数圆括号）   | 无       | `new Constructor(...)` |
| 20     | 普通函数调用          | 从左到右 | `fn(...)`              |
| 20     | 可选链                | 从左到右 | `obj?.prop`            |
| 19     | new（没有参数圆括号） | 从右到左 | `new Constructor`      |
| 18     | 后置自增              | 无       | `...++`                |
| 18     | 后置自减              | 无       | `...--`                |
| 17     | 逻辑非                | 从右到左 | `!...`                 |
| 17     | 按位非                | 从右到左 | `~...`                 |
| 17     | 一元加法              | 从右到左 | `+...`                 |
| 17     | 一元减法              | 从右到左 | `-...`                 |
| 17     | 前置自增              | 从右到左 | `++...`                |
| 17     | 前置自减              | 从右到左 | `--...`                |
| 17     | typeof                | 从右到左 | `typeof...`            |
| 17     | void                  | 从右到左 | `void...`              |
| 17     | delete                | 从右到左 | `delete...`            |
| 17     | await                 | 从右到左 | `await...`             |
| 16     | 幂                    | 从右到左 | `...**...`             |
| 15     | 乘法                  | 从左到右 | `...*...`              |
| 15     | 除法                  | 从左到右 | `.../...`              |
| 15     | 取余                  | 从左到右 | `...%...`              |
| 14     | 加法                  | 从左到右 | `...+...`              |
| 14     | 减法                  | 从左到右 | `...-...`              |
| 13     | 按位左移              | 从左到右 | `...<<...`             |
| 13     | 按位右移              | 从左到右 | `...>>...`             |
| 13     | 无符号右移            | 从左到右 | `...>>>...`            |
| 12     | 小于                  | 从左到右 | `...<...`              |
| 12     | 小于或等于            | 从左到右 | `...<=...`             |
| 12     | 大于                  | 从左到右 | `...>...`              |
| 12     | 大于或等于            | 从左到右 | `...>=...`             |
| 12     | in                    | 从左到右 | `...in...`             |
| 12     | instanceof            | 从左到右 | `...instanceof...`     |
| 11     | 宽松等于              | 从左到右 | `...==...`             |
| 11     | 宽松不等于            | 从左到右 | `...!=...`             |
| 11     | 严格等于              | 从左到右 | `...===...`            |
| 11     | 严格不等于            | 从左到右 | `...!==...`            |
| 10     | 按位与                | 从左到右 | `...&...`              |
| 9      | 按位异或              | 从左到右 | `...^...`              |
| 8      | 按位或                | 从左到右 | `...|...`              |
| 7      | 逻辑与                | 从左到右 | `...&&...`             |
| 6      | 逻辑或                | 从左到右 | `...||...`             |
| 5      | 空值合并              | 从左到右 | `...??...`             |
| 4      | 条件运算符            | 从右到左 | `...?...:...`          |
| 3      | 赋值                  | 从右到左 | `...=...`              |
| 3      | 赋值                  | 从右到左 | `...+=...`             |
| 3      | 赋值                  | 从右到左 | `...-=...`             |
| 3      | 赋值                  | 从右到左 | `...**=...`            |
| 3      | 赋值                  | 从右到左 | `...*=...`             |
| 3      | 赋值                  | 从右到左 | `.../=...`             |
| 3      | 赋值                  | 从右到左 | `...%=...`             |
| 3      | 赋值                  | 从右到左 | `...<<=...`            |
| 3      | 赋值                  | 从右到左 | `...>>=...`            |
| 3      | 赋值                  | 从右到左 | `...>>>=...`           |
| 3      | 赋值                  | 从右到左 | `...&=...`             |
| 3      | 赋值                  | 从右到左 | `...^=...`             |
| 3      | 赋值                  | 从右到左 | `...|=...`             |
| 3      | 赋值                  | 从右到左 | `...&&=...`            |
| 3      | 赋值                  | 从右到左 | `...||=...`            |
| 3      | 赋值                  | 从右到左 | `...??=...`            |
| 2      | yield                 | 从右到左 | `yield...`             |
| 2      | yield*                | 从右到左 | `yield*...`            |
| 1      | 展开运算符            | 无       |                        |
| 0      | 逗号                  | 从左到右 | `...,...`              |



## 算术运算符

​		对左、右运算元进行算术运算，返回一个 `Number` 。非 `Number` 的运算元会被隐式转换成 `Number` （加法除外）。

> **转换规则：**
>
> - 对于二元加法运算符，若左、右运算元都不是 `String` ，则非 `Number` 的运算元会被转换为 `Number`
> - 对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被转换为  `String` 
> - 对于其它算术运算符，所有非 `Number` 的运算元都会被转换为 `Number` 

| 名称 | 运算符 | 名称       | 运算符 |
| ---- | ------ | ---------- | ------ |
| 加   | `+`    | 求幂       | `**`   |
| 减   | `-`    | 自增       | `++`   |
| 乘   | `*`    | 自减       | `--`   |
| 除   | `/`    | 一元正值符 | `+`    |
| 取余 | `%`    | 一元负值符 | `-`    |



### 求幂

​		以左运算元为底数，以右运算元为指数，返回它们的乘方。注意，该运算符的关联性是从右到左，因此 `2 ** 2 ** 3` 等价于 `2 ** (2 ** 3)`，不等价于 `(2 ** 2) ** 3` 。



### 自增 和 自减

​		对于前置自增，先令运算元自增 `1` ，再返回运算元的值。对于后置自增，先返回运算元的值，再令运算元自增 `1` 。自减运算符同理。



## 字符串运算符

​		对于二元加法运算符，若有至少一个运算元是 `String` ，则非 `String` 的运算元会被隐式转换为 `String` ，然后再进行字符串的连接，最后返回连接的结果。



##  赋值运算符

| 名称       | 运算符 | 描述                            | 返回值             |
| ---------- | ------ | ------------------------------- | ------------------ |
| 普通赋值   | `=`    | 将右运算元的值分配给左运算元    | 右运算元的值       |
| 加赋值     | `+=`   | `a += b`   等价于 `a = a + b`   | `a + b`   的返回值 |
| 减赋值     | `-=`   | `a -= b`   等价于 `a = a - b`   | `a - b`   的返回值 |
| 乘赋值     | `*=*`  | `a *= b`   等价于 `a = a * b`   | `a * b`   的返回值 |
| 除赋值     | `/=`   | `a /= b`   等价于 `a = a / b`   | `a / b`   的返回值 |
| 取余赋值   | `%=`   | `a %= b`   等价于 `a = a % b`   | `a % b`   的返回值 |
| 求幂赋值   | `**=`  | `a **= b` 等价于 `a = a ** b`   | `a ** b` 的返回值  |
| 逻辑与赋值 | `&&=`  | `a &&= b` 等价于 `a && (a = b)` | `a` 最终的值       |
| 逻辑或赋值 | `||=`  | `a ||= b` 等价于 `a || (a = b)` | `a` 最终的值       |
| 逻辑空赋值 | `??=`  | `a ??= b` 等价于 `a ?? (a = b)` | `a` 最终的值       |



### 证明 “普通赋值运算符的返回值是右运算元的值”：

​		[《运算符优先级》](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)： ”这是因为赋值运算符的返回结果就是赋值运算符右边的那个值“ 。

```js
let a, b, c;

(a = b) = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment (1)

c = 1;       // 1                                                          (2)
```

​		由 (1) 式可知，普通赋值运算符的返回值不是运算元本身，而是一个值，再结合 (2) 式可知，这个值就是右运算元的值。



### 证明 `a &&= b` 等价于 `a && (a = b)` ，不等价于 `a = a && b`：

​		逻辑与赋值的定义是：若左运算元的布尔值为 `true` ，则将右运算元的值分配给左运算元，否则不对左运算元进行赋值操作。由定义可知，逻辑与赋值具有短路计算的特点，因此 `a &&= b` 应当等价于 `a && (a = b)`，而不是 `a = a && b`。

​		对于逻辑或赋值、逻辑空赋值，同理。



## 逻辑运算符

| 名称   | 运算符 | 语法     | 描述                                                         |
| ------ | ------ | -------- | ------------------------------------------------------------ |
| 逻辑与 | `&&`   | `a && b` | 若 `a` 的布尔值为 `true`   ，则返回 `b` 的初始值；<br />若 `a` 的布尔值为 `false` ，则返回 `a` 的初始值，忽略 `b`； |
| 逻辑或 | `||`   | `a || b` | 若 `a` 的布尔值为 `true`   ，则返回 `a` 的初始值，忽略 `b` ；<br />若 `a` 的布尔值为 `false` ，则返回 `b` 的初始值； |
| 逻辑非 | `!`    | `!a`     | 若 `a` 的布尔值为 `true`   ，则返回 `false` ；<br />否则返回 `true` ； |
| 逻辑空 | `??`   | `a ?? b` | 若 `a` 的初始值为 `null` 或 `undefined` ，则返回 `b` 的初始值；<br />否则返回 `a` 的初始值，忽略 `b` ； |

> 注：`a` 和 `b` 是变量或表达式。变量的初始值就是变量的值，表达式的初始值就是表达式的计算结果。



### 逻辑或

​		从左向右逐个检查运算元，返回首个布尔值为 `true` 的运算元的初始值，并忽略剩余的运算元。若一直没有找到布尔值为 `true` 的运算元，则返回最后那个运算元的初始值。

​		比如对于 `a && b && c` ，JavaScript 引擎会这么做：

1. 从左向右逐个检查运算元；
2. 若当前运算元的初始值的数据类型不是布尔值，则隐式转换为布尔值；
3. 若当前运算元的布尔值为 `true`   ，则立即返回当前运算元的初始值，并忽略剩余的运算元；
4. 若所有运算元的布尔值为 `false` ，则返回最后那个运算元的初始值；



### 逻辑与

​		从左向右逐个检查运算元，返回首个布尔值为 `false` 的运算元的初始值，并忽略剩余的运算元。若一直没有找到布尔值为 `false` 的运算元，则返回最后那个运算元的初始值。

**短路计算：**

​		`&&` 、 `||` 、 `??` 具有能够忽略运算元的特性， “运算元被忽略” 是指该运算元没有被执行，因此被忽略的运算元中的错误、副作用、函数调用等都不会被触发。这种忽略运算元的行为被称为短路计算。

​		短路计算常用于简化判断语句，但它也会降低代码的可读性。

```js
if (x > 0) fn(); // 旧

(x > 0) && fn(); // 新：利用短路计算简化if判断
```



## 一元运算符

| 名称     | 运算符   | 语法                       | 描述 |
| -------- | -------- | -------------------------- | ---- |
| 一元加法 | `+`      | `+a`                       |      |
| 一元减法 | `-`      | `-a`                       |      |
| 逻辑非   | `!`      | `!a`                       |      |
| 按位非   | `~`      |                            |      |
| void     | `void`   | `void a`     或 `void (a)` |      |
| typeof   | `typeof` | `typeof a` 或 `typeof (a)` |      |
| delete   | `delete` | `delete a`                 |      |



### void

​		执行右运算元，然后返回 `undefined`。

**语法：**

```js
void expression;
```

```js
void (expression);
```

**使用 void 来构造 IIFE：**

​		与其它形式的 IIFE 不同的是，由 `void` 构造的 IIFE 一定会返回 `undefined` 。

```js
void function iife(){}();
```

```js
void (function iife(){}());
```

**JavaScript URIS：**

​		使该超链接标签的点击无响应。

```html
<a href="javascript: void 0;"></a>
```

```html
<a href="javascript: void(0);"></a>
```



### typeof

​		返回一个 `String` ，用来表示右运算元的数据类型。

**语法：**

```js
typeof a;
```

```js
typeof (a);
```

| 数据类型                               | 返回值             |
| -------------------------------------- | ------------------ |
| `Undefined`                            | `'undefined'`      |
| `Null`                                 | `'object'`         |
| `Boolean`                              | `'boolean'`        |
| `Number`                               | `'number'`         |
| `Bigint`                               | `'bigint'`         |
| `String`                               | `'string'`         |
| `Symbol`                               | `'symbol'`         |
| `Function`                             | `'function'`       |
| 宿主对象（如 `window` 、 `document` ） | 取决于浏览器的实现 |
| 其它对象                               | `'object'`         |
| 未声明的变量                           | `'undefined'`      |

**历史错误 `typeof null` **：

​		`typeof null` 的返回值是 `'object'` ，这是一个历史错误。

**侵犯标准的宿主对象：**

```js
typeof document.all; // 'undefined'
```

​		ECMAScript 规范外的对象可以自定义自己的 `typeof` 的返回值，但显然 `document.all` 对自己的 `typeof ` 定义并不合理，这被视为是对 ECMAScript 规范的侵犯，目前该接口已被废弃，但部分浏览器仍支持它。



### delete

​		删除对象自身的指定属性，但不会删除对象原型链上的同名属性。

**语法：**

```js
delete obj.prop;
```

```js
delete obj[expr];
```

**返回值：**

- `false` ：非严格模式下，`delete` 不可配置的属性会返回 `false` ，且操作无效（严格模式下，则会抛出错误）；
- `true` ：其余情况都返回 `true` ；

**陷阱 1 ： `delete` 不存在的属性**

​		`delete` 不存在的属性会返回 `true` ，且被 `delete` 属性的对象没有任何变化。

```js
delete {}.a; // true
```

**陷阱 2 ： `delete` 由 `var` 、 `let` 、 `const` 、 `function` 声明的变量：**

​		任何作用域内，由声明关键字声明的变量是某个对象的不可配置的属性，由赋值来创建的变量是某个对象的可配置的属性。以 `var` 为例，`let` 、 `const` 、 `function` 同理（MDN说的）。

```js
a = 1;
var b = 2;

Object.getOwnPropertyDescriptor(window, "a").configurable; // true
Object.getOwnPropertyDescriptor(window, "b").configurable; // false
```

​		`delete` 不可配置的属性就会返回 `false` ，或抛出错误。

```js
// 全局作用域
var global_a = 1;

let global_b = 2;

const global_c = 3;

function global_f() {};

delete global_a; // false
delete global_b; // false
delete global_c; // false
delete global_f; // false

// 函数作用域
void (function (){
    
    var a = 1;
    
    let b = 2;
    
    const c = 3;
    
    function f() {};
    
    delete a; // false
	delete b; // false
	delete c; // false
	delete f; // false
    
}())
```

**陷阱 3 ： `delete` 数组元素：**

​		`delete` 一个数组的元素，就会清空这个元素的内容，但不会释放掉这个元素所占据的内存空间，所以被 `delete` 掉的元素的值为 `undefined` ，意义为 empty 。数组的长度不会改变，其它元素的下标不会重排。

```js
const array = [1, 2, 3];

delete array[0];

array;    // [empty, 2, 3]
array[0]; // undefined
```



## 三元运算符

​		又被称为条件运算符。

**语法：**

```js
condition ? expr_1 : expr_2;
```

- 若 `condition` 的布尔值是 `true` ，则执行 `expr_1` ，忽略 `expr_2` ，最后返回 `expr_1` 的初始值；
- 否则，忽略 `expr_1` ， 执行 `expr_2` ，最后返回 `expr_2` 的初始值；



## ⏳ 比较运算符

> ⏳：《部分转换规则》和《部分比较规则》不齐全，需要继续补充。

​		严格比较运算符会直接比较左、右运算元的数据类型和值。其它的比较运算符会将左、右运算元隐式转换为同一种数据类型，再比较它们的值。

| 名称     | 运算符 | 名称       | 运算符 | 名称 | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ | ---- | ------ | ---------- | ------ |
| 严格相等 | `===`  | 严格不相等 | `!==`  | 大于 | `>`    | 大于或等于 | `>=`   |
| 宽松相等 | `==`   | 宽松不相等 | `!=`   | 小于 | `<`    | 小于或等于 | `<=`   |

**部分转换规则：**

- 若两个运算元分别是 `Number` 和 `String` ，则 `String` 会被转换为 `Number`；
- 若两个运算元分别是 `Number` 和 `Boolean` ，则 `Boolean` 会被转换为 `Number` ；

**部分比较规则：**

- 若两个运算元都是 `Object` ，则当它们都指向同一个对象时，认为它们宽松相等和严格相等，否则认为它们宽松不相等和严格不相等；
- `NaN` 不与任何值（包括它自己）宽松相等或严格相等；
- `+0` 和 `-0` 严格相等；



## 逗号运算符

**语法：**

​		从左向右的逐个执行运算元，最后返回最后那个运算元的执行结果。

```
expr_1, expr_2, ..., expr_n;
```

**示例：**

```js
const exprA = _ => 1;
const exprB = _ => 2;

(exprA(), exprB()); // 2
```

**陷阱：**

​		声明语句中的逗号不是逗号运算符，表达式中的逗号才是逗号运算符。



## 可选链运算符

​		若左运算元为 `null` 或 `undefined` ，则返回 `undefined` ，并忽略右运算元，否则执行右运算元（通常是属性访问或函数调用）。

**语法：**

```js
obj?.property;
```

```js
obj?.[expression];
```

```js
array?.[index];
```

```
function?.();
```

示例：

```js
const obj = {f: _ => 1};

obj.f?.(); // 1
obj.a?.(); // undefined
```



## in 运算符

​		若该属性存在于该对象或该对象的原型链上，则返回 `true` ，否则返回 `false` 。

**语法：**

```js
prop in obj;
```

-  `prop` ： `String` 或 `Symbol` ，代表属性名或数组索引，其它数据类型的值都会被隐式转换为 `String` 
-  `obj`   ： `Object`

**示例：**

```js
'toString' in {}; // true
```

```js
0 in [1, 2, 3];   // true
```



## instanceof 运算符

​		若对象 A 的 `prototype` 属性存在于对象 B 的原型链上，则返回 `true` ，否则返回 `false` 。

**语法：**

```js
obj_b instanceof obj_a;
```

**示例：**

```js
const A = function() {};
const a = new A();

a instanceof A;      // true
a instanceof Object; // true
```



## 位运算符

> ​		这类运算符在实际开发中很少被用到，因此暂时忽略它们，如果你更感兴趣，可以从这里开始学习 🔗https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators

| 名称     | 运算符 | 名称       | 运算符 |
| -------- | ------ | ---------- | ------ |
| 按位与   | `&`    | 左移       | `<<`   |
| 按位或   | `|`    | 右移       | `>>`   |
| 按位异或 | `^`    | 无符号右移 | `>>>`  |
| 按位非   | `~`    |            |        |

