# 数据类型

JavaScript 是一门动态的弱类型语言。

静态类型语言的变量的数据类型在代码的编译阶段就被确定了，动态类型语言的变量的数据类型在代码的执行阶段才被确定。

弱类型语言的变量的数据类型可以隐式转换，强类型语言的变量的数据类型不可以隐式转换。

ECMAScript 规定了 8 种数据类型，其中 7 种是原始类型， 1 种是引用类型。

## 原始类型

原始类型又称为基本数据类型，原始类型的值称为原始值。

### Number 类型

`number` 是基于 IEEE-754 标准的双精度 64 位二进制格式的值，可以安全的存储 `[ -2^53+1, 2^53-1 ]` 范围的值，显然 ECMAScript 中没有整数的数字类型，只有浮点数。

除了常规的数字， ECMAScript 还包括一些特殊数值，具体是： `Infinity` 、 `-Infinity` 、 `NaN` 。

#### 极值

浮点数的最大值是 `Number.MAX_VALUE` ，约为 `1.798e+308` ，最小值是 `Number.MIN_VALUE` ， 约为 `5e-324` ，注意最小浮点数并不等于 `0` ，而是无限接近于 `0` 。

整数的最大值是 `Number.MAX_SAFE_INTEGER` ，即为 `2^53-1` ，即 `9007199254740991` ，最小值是 `Number.MIN_SAFE_INTEGER` ，即 `-2^53-1` ，即 `-9007199254740991` 。

#### 特殊数值

ECMAScript 中还包括一些特殊的数值，分别是： `Infinity` 、 `-Infinity` 、 `NaN` 。

##### NaN

`NaN` 是英文“not a number”的缩写，它代表计算错误，当数学操作不正确时，表达式便会返回该值，如果数学表达式中有一个 `NaN` ，则该表达式的运算结果必然也是 `NaN` ，只有一个例外： `NaN ** 0` 的结果为 `1` 。

> 数学运算是安全的：在 JavaScript 程序中，我们做的任何离谱的数学运算都不会引发错误（比如 `1 / 0` 、 `"string" + 1` 等等），程序也不会因此被杀死，最坏的情况下我们也只是得到 `NaN` 的结果而已。

此外， `NaN` 是 ECMAScript 中唯一一个自己不等于自己的值：

```js
NaN ==  NaN; // 返回false
NaN === NaN; // 返回false
```

虽然浏览器运行时提供了 `window.isNaN( v )` 来鉴定 `NaN` ，但是实际上这个 API 并不可靠，因为输入 `NaN` 或 `undefined` 或 `非空非数字字符串` 或 `函数` 或 `对象` 时，它都会返回 `true` ：

如果想要鉴定 `NaN` ，请使用 `Number.isNaN( v )` 方法，或者它的 `Polyfill` ：

```js
if ( !Number.isNaN ) { 

    Number.isNaN = function( n ) { return n !== n };

}
```

##### Infinity 和 -Infinity

`Infinity` 代表数学中的无穷大 ∞ 。

JavaScript 无法存储和表示超出数值极限的值，当数值超出极限后，数值会被"就近"的舍入到 `Number.MAX_VALUE` 或 `Infinity` ，比如：

```js
Number.MAX_VALUE + Math.pow( 2, 969 ); // 返回Number.MAX_VALUE
Number.MAX_VALUE + Math.pow( 2, 970 ); // 返回Infinity
```

##### 数字分隔符

假如我们需要表示 10 亿，显然，我们可以这样写：

```js
const billion = 1000000000;
```

我们也可以使用下划线作为分隔符：

```js
const billion = 1_000_000_000;
```

这里的下划线是语法糖，它使数字具有更强的可读性，在源码编译时，引擎会自动忽略数字之间的下划线，所以下划线不仅仅可以出现在千分位，还可以出现在百分位、十分位等......当然也可以用在其他进制的数字中，比如：

```js
const sixteen = 0x1_0; // 16
```

##### 不精确的小数

ECMAScript 使用二进制来存储数字，虽然二进制可以准确的表示所有整数，但不能准确的表示所有小数，比如 `0.5` 的二进制值是 `0.1` ，但是 `0.1` 的二进制值是 `0.000110011001100...` ，这是一个无限循环小数，循环节是 1100 。

IEEE 754 使用 64 位的二进制来表示一个数值，其中 52 位用于存储整数， 11 位用于存储小数， 1 位用于存储符号，当遇到无限小数的二进制值时， IEEE 754 会进行四舍五入，这就是 ECMAScript 无法准确表示某些小数的原因。

这会带来什么问题呢？比如：

```js
( 0.1 + 0.2 ) === 0.3; // 返回false！
```

```js
6.35.toFixed( 1 ); // 返回"6.3"
```

这是因为：

```js
0.1.toFixed( 20 );           // 0.10000000000000000555
0.2.toFixed( 20 );           // 0.20000000000000001110
0.3.toFixed( 20 );           // 0.29999999999999998890
( 0.1 + 0.2 ).toFixed( 20 ); // 0.30000000000000004441

6.35.toFixed( 20 );          // "6.34999999999999964473"
```

如何解决 `0.1 + 0.2` 不等于 `0.3` 的问题呢？办法就是：如果 2 个数值的差值的绝对值小于某个误差范围，则认为这 2 个数值是相等的，一般我们取机器精度 `Number.EPSILON` 来作这个误差范围，这是一个鉴定 2 个数值是否相等的函数：

```js
function numbersCloseEnoughToEqual( n_1, n_2 ) {
    
    return Math.abs( n_1 - n_2 ) < Number.EPSILON;
    
}
```

我们来试试这个方法！

```js
numbersCloseEnoughToEqual( 0.1 + 0.2, 0.3 ); // 返回true！
```

`Number.EPSILON` 是 ES6 的新特性，它的值是 `2^-52` ，这是它的 Polyfill ：

```js
if ( !Number.EPSILON ) {
    
    Number.EPSILON = Math.pow( 2, -52 );
    
}
```

如何解决 `6.35.toFixed( 1 )` 等于 `"6.3"` 呢？在进行舍入之前，先让 `6.35` 更加接近整数，然后再舍入，比如：

```js
Math.round( 6.35 * 10 ) / 10; // 返回 6.4
```

为什么要这么做呢？因为 `63.5`  是没有精度损失的，因为小数部分的 `0.5` 是 `1/2` ，以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确的表示，这时再进行舍入就没问题了。

```js
63.5.toFixed( 20 ); // "63.50000000000000000000"
```

##### 冷知识

可以省略小数点前面的 `0` ，比如 `0.1` 可以简写成 `.1` ，我个人更喜欢 `0.1` 这种写法，因为更清晰。

小数部分多余的 `0` 可以省略，比如 `0.10` 可以简写成 `0.1` ，ECMAScript 不是 C++ ，它不区分整数和浮点数。

在 ECMAScript 中，指数的写法有好多种，下面的写法都是合法的：

```js
2E5;  // 200000
2e5;  // 20000

2E+5; // 200000
2e+5; // 200000

2E-5; // 0.00002
2e-5; // 0.00002
```

ECMAScript 默认使用十进制来计数，除了十进制外，它还支持使用二进制、八进制和十六进制，我们需要为数字添加特殊的标识才能启用这些进制，这就是那些特殊的标识：

```js
/* 二进制 */
0b10; // 2

/* 八进制 */
0o70; // 56

/* 十六进制 */
0xf0; // 240
```

> 冷知识：你可能会在某些代码中看到以 `0` 为前缀的数字，实际上这也是八进制的格式，但该特性已经被淘汰了，为了向后兼容，非严格模式仍支持该特性，严格模式则会报错。

如果你还想使用其他的进制，比如 3 进制，你就可以使用 `Number.prototype.toString( [ radix ] )` 方法，该方法会将数字值转换为指定进制的数字字符串， `radix` 的取值范围是 `[ 2, 36 ]` ，表示将要采用的进制，缺省时将取 `10` ，这是一个例子：

```js
3..toString( 3 ); // 返回"10"，这是将3转换为3进制下的数字字符串
```

在 ECMAScript 中，数字字面量可以直接调用 `Number.prototype` 上的方法，不过需要小心“小数点”问题，下面罗列了各种情况：

| 情况                               | 解决方案                                                     |
| ---------------------------------- | ------------------------------------------------------------ |
| 如果数字字面量有小数点，比如 `0.1` | 直接使用点号属性访问器来调用方法，比如 `0.1.toString()`      |
| 如果数字字面量是指数               | 直接使用点号属性访问器来调用方法，比如 `2e5.toString()`      |
| 如果数字字面量是整数，比如 `1`     | 1.改造成小数后再使用点号属性访问器来调用方法，比如 `1.0.toString()` <br />2.添加圆括号后再使用点号属性访问器来调用方法，比如 `( 1 ).toString()` <br />3.添加空格尾缀后再使用点号属性访问器来调用方法，比如 `1 .toString()` <br />4.添加换行符后再使用点号属性访问器来调用方法<br />5.添加小数点后再使用点号属性访问器来调用方法，比如 `1..toString()` |

### BigInt 类型

TODO

### String 类型

#### Boolean 类型

### Null 类型

### Undefined 类型

### Symbol 类型

## 引用类型

引用类型又称为复杂数据类型，引用类型的值称为引用值。

## 待定-原始类型和引用类型的区别

首先，在存储方式上，原始值存储在栈空间中，引用值存储在堆空间中。

 JavaScript 引擎可以直接获取存储在栈空间中的值，对于存储在堆空间中的值， JavaScript 引擎必须先从栈空间中获得指向引用值的指针（地址字符串），然后再根据指针从堆空间中获取引用值。

之所以要这么设计，是为了加快查找值的速度，因为所有原始值所占的存储空间大小是固定不变的，如果栈空间中只存储原始值，那么每个原始值的地址都相差 N 个偏移量